import fs from 'fs';
import path from 'path';
import { dsvFormat } from 'd3-dsv';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const dataDir = path.join(__dirname, '../src/data');
const outputFilePath = path.join(dataDir, 'processedData.js');
const rawDataFilePath = path.join(dataDir, 'rawData.json');

// 1. Find all CSV files in the data directory
const csvFiles = fs.readdirSync(dataDir).filter(file => file.endsWith('.csv'));

let allRows = [];
const leagueStartDates = new Map();

// 2. Read and parse each CSV file
for (const file of csvFiles) {
    const filePath = path.join(dataDir, file);
    const leagueName = file.split('.')[0];
    const fileContent = fs.readFileSync(filePath, 'utf-8');
    
    // Handle inconsistent headers by finding the first real data line
    const lines = fileContent.split('\n');
    const headerIndex = lines.findIndex(line => line.startsWith('League;Date;Get;Pay;Value;Confidence'));
    if (headerIndex === -1) continue;

    const header = lines[headerIndex];
    const dataLines = lines.slice(headerIndex + 1).join('\n');
    
    const rows = dsvFormat(';').parse(header + '\n' + dataLines);

    // 3. Determine league start date (first valid date entry in the file)
    if (rows.length > 0) {
        for(const row of rows) {
            if (row.Date) {
                const date = new Date(row.Date);
                if (!isNaN(date.getTime())) {
                    leagueStartDates.set(leagueName, date);
                    break;
                }
            }
        }
    }

    // 4. Collect all relevant rows
    allRows.push(...rows.filter(row => row.Pay === 'Chaos Orb' && row.Value && !isNaN(parseFloat(row.Value))));
}

const processed = {};

const dayDifference = (date1, date2) => {
    const d1 = new Date(date1);
    const d2 = new Date(date2);
    d1.setUTCHours(0, 0, 0, 0);
    d2.setUTCHours(0, 0, 0, 0);
    const diffTime = Math.abs(d2.getTime() - d1.getTime());
    return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
}

// 5. Process all rows to calculate day and price
allRows.forEach(row => {
    const itemName = row.Get;
    if (!itemName || !row.League || !row.Date) return;

    const leagueStartDate = leagueStartDates.get(row.League);
    if (!leagueStartDate) return;

    const currentDate = new Date(row.Date);
    if (isNaN(currentDate.getTime())) return;

    const day = dayDifference(currentDate, leagueStartDate) + 1; // Day 1 based index

    const price = parseFloat(row.Value);
    if(isNaN(price)) return;

    if (!processed[itemName]) {
        processed[itemName] = {};
    }
    if (!processed[itemName][day]) {
        processed[itemName][day] = [];
    }
    processed[itemName][day].push(price);
});

// 6. Calculate averages
const averagedData = {};
for (const itemName in processed) {
    averagedData[itemName] = [];
    for (const day in processed[itemName]) {
        const prices = processed[itemName][day];
        const averagePrice = prices.reduce((a, b) => a + b, 0) / prices.length;
        averagedData[itemName].push({
            day: parseInt(day),
            price: averagePrice,
        });
    }
    // Sort values by day
    averagedData[itemName].sort((a, b) => a.day - b.day);
}

// 7. Format for the chart
const chartData = Object.keys(averagedData).map(itemName => ({
    name: itemName,
    values: averagedData[itemName]
}));

// 8. Write to file
const fileContent = `// This file is auto-generated by scripts/processData.js
export const processedChartData = ${JSON.stringify(chartData, null, 2)};
`;

fs.writeFileSync(outputFilePath, fileContent, 'utf-8');
fs.writeFileSync(rawDataFilePath, JSON.stringify(chartData, null, 2), 'utf-8'); // also save as pure JSON for other uses

console.log(`Processed data has been written to ${outputFilePath}`);
console.log(`Raw JSON data has been written to ${rawDataFilePath}`);